#!/bin/sh

is_remote=0

explain_select_in_sql() {
  if [ "$#" -ne 1 ]; then
    echo "Usage: explain_select_in_sql <sql_file_path>" >&2
    return 1
  fi

  __sql_file="$1"

  echo "File \"${__sql_file}\":" >&2

  __basename="$(basename "${__sql_file}" .sql)" || return "$?"
  __file_path_without_extension="./sql/2_query/${__basename}" || return "$?"

  __file_path_query_plan="${__file_path_without_extension}.log"
  __file_link="${__file_path_without_extension}.lnk"
  __file_html="${__file_path_without_extension}.html"

  rm -rf "./sql/2_query/${__file_path_query_plan}" "./sql/2_query/${__file_link}" "./sql/2_query/${__file_html}" || return "$?"

  # Create temp file
  __file_path_sql_with_explain="$(mktemp --tmpdir="${__cache_directory}")" || return "$?"

  # ========================================
  # Get Query Plan
  # ========================================
  echo "  Getting Query Plan..." >&2
  sed -E 's/^SELECT/SET track_io_timing = on\; EXPLAIN (ANALYZE, VERBOSE, COSTS, SETTINGS, BUFFERS, WAL, TIMING, SUMMARY, MEMORY, FORMAT TEXT) SELECT/' "${__sql_file}" > "${__file_path_sql_with_explain}" || return "$?"
  ./shell/psql.sh "${__file_path_sql_with_explain}" | grep -v '^You are now connected to database' | grep -Ev '^SET' > "${__file_path_query_plan}" || return "$?"
  echo "  Getting Query Plan: success!" >&2
  # ========================================

  if [ "${is_remote}" = "0" ]; then
    return 0
  fi

  echo "  Generating request..." >&2
  # Create temp file
  __file_path_request="$(mktemp --tmpdir="${__cache_directory}")" || return "$?"
  # shellcheck disable=SC2002
  cat << EOF | tee "${__file_path_request}" > /dev/null || return "$?"
{
  "plan": "$(cat "${__file_path_query_plan}" | tr '\n' '\r' | sed 's/\r/\\n/g')"
}
EOF
  echo "  Generating request: success!" >&2

  # We pass our plan to "explain.tensor.ru" for it to make it in colorful HTML
  echo "  Getting Query Plan as HTML..." >&2
  __request_hash="$(sha256sum "${__file_path_request}" | cut -d ' ' -f 1)" || return "$?"
  __file_response="./cache/$(basename "${__sql_file}" .sql)_${__request_hash}.html"
  if [ -f "${__file_response}" ]; then
    echo "  Found cached file!" >&2
  else
    echo "    Passing Query Plan to \"explain.tensor.ru\"..." >&2
    __response="$(
      curl --fail --silent --show-error -X POST https://explain.tensor.ru/explain \
        -H "Content-Type: application/json" \
        -d @"${__file_path_request}"
    )" || return "$?"
    echo "    Passing Query Plan to \"explain.tensor.ru\": success!" >&2

    # Then we get HTML link
    echo "    Getting HTML link..." >&2
    __url_explained="https://explain.tensor.ru$(echo "${__response}" | sed -En 's/^Found. Redirecting to (.+)$/\1/p')" || return "$?"
    if [ -z "${__url_explained}" ]; then
      echo "    Failed to get URL from response! Response:
${__response}" >&2
      return 1
    fi
    # shellcheck disable=SC2320
    echo "${__url_explained}" > "${__file_link}" || return "$?"
    echo "    Getting HTML link: success!" >&2

    # Because colored HTML is generated by JavaScript on page load, we use headless browser to get it
    echo "    Getting HTML..." >&2
    ./venv/bin/python ./python/explain_query_plan.py "${__url_explained}#parsed" > "${__file_response}" || return "$?"
    echo "    Getting HTML: success!" >&2
  fi
  __html="$(cat "${__file_response}")" || return "$?"
  echo "  Getting Query Plan as HTML: success!" >&2

  echo "  Getting HTML pre tag content..." >&2
  __html_pre_tag_content="$(echo "${__html}" | tr '\n' '\r' | sed -En 's/^.+(<pre id="parsed_pl" class="expl">([^<]*<\/?span[^>]*>)+[^<]+<\/pre>).+/\1/p' | tr '\r' '\n' | tr -d 'â€²')" || return "$?"
  if [ -z "${__html_pre_tag_content}" ]; then
    echo "  Failed to get HTML pre tag content" >&2
    return 1
  fi
  echo "  Getting HTML pre tag content: success!" >&2

  echo "  Saving HTML file..." >&2
  cat << EOF | tee "${__file_html}" > /dev/null || return "$?"
<html lang="en, ru">
  <head>
    <meta charset="UTF-8">
    <title>Query Plan</title>
    <link href="./explain.css" rel="stylesheet">
  </head>
  <body style="font-size: ${__font_size}pt; background-color: #1b1b1b">
    ${__html_pre_tag_content}
  </body>
</html>
EOF
  # Add BOM if possible (not critical)
  if which dos2unix > /dev/null 2>&1; then
    dos2unix --add-bom "${__file_html}" || return "$?"
  else
    echo "\"dos2unix\" utility is not installed - BOM will not be added!" >&2
    echo "Consider installing it to support russian letters in HTML." >&2
  fi
  echo "  Saving HTML file: success!" >&2

  # Clear temp file
  rm "${__file_path_sql_with_explain}" "${__file_path_request}" || return "$?"
}

main() {
  if [ "$#" -gt 0 ]; then
    __font_size="$1" && shift || return "$?"
  else
    __font_size=12
  fi

  __cache_directory="./cache"

  # Create cache directory for Query Plans if not already exists
  mkdir --parents ./cache || return "$?"

  # ========================================
  # Select from one table
  # ========================================
  # Without indexes
  ./shell/psql.sh ./sql/2_query/1_1_drop_indexes.sql || return "$?"
  explain_select_in_sql ./sql/2_query/1_2_select_from_one_table.sql || return "$?"

  # With indexes
  ./shell/psql.sh ./sql/2_query/1_3_create_indexes.sql || return "$?"
  cp ./sql/2_query/1_2_select_from_one_table.sql ./sql/2_query/1_4_select_from_one_table.sql || return "$?"
  explain_select_in_sql ./sql/2_query/1_4_select_from_one_table.sql || return "$?"

  # Clear indexes
  ./shell/psql.sh ./sql/2_query/1_1_drop_indexes.sql || return "$?"
  # ========================================

  # ========================================
  # Select from two tables
  # ========================================
  # Without indexes
  ./shell/psql.sh ./sql/2_query/2_1_drop_indexes.sql || return "$?"
  explain_select_in_sql ./sql/2_query/2_2_select_from_two_tables.sql || return "$?"

  # With indexes
  ./shell/psql.sh ./sql/2_query/2_3_create_indexes.sql || return "$?"
  cp ./sql/2_query/2_2_select_from_two_tables.sql ./sql/2_query/2_4_select_from_two_tables.sql || return "$?"
  explain_select_in_sql ./sql/2_query/2_4_select_from_two_tables.sql || return "$?"

  # Clear indexes
  ./shell/psql.sh ./sql/2_query/2_1_drop_indexes.sql || return "$?"
  # ========================================

  # ========================================
  # Select from two tables
  # ========================================
  # Without indexes
  ./shell/psql.sh ./sql/2_query/3_1_drop_indexes.sql || return "$?"
  explain_select_in_sql ./sql/2_query/3_2_select_text.sql || return "$?"

  # With indexes
  ./shell/psql.sh ./sql/2_query/3_3_create_indexes.sql || return "$?"
  cp ./sql/2_query/3_2_select_text.sql ./sql/2_query/3_4_select_text.sql || return "$?"
  explain_select_in_sql ./sql/2_query/3_4_select_text.sql || return "$?"

  # Clear indexes
  ./shell/psql.sh ./sql/2_query/3_1_drop_indexes.sql || return "$?"
  # ========================================
}

main "${@}" || exit "$?"
